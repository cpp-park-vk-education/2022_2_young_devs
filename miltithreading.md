# ДЗ6 - Многопоточное взаимодействие 

Мной был внедрен механизм многопоточного взаимодействия. Задача заключается в том, чтобы обрабатывать ходы пользователей в нескольких игровых комнатах параллельно. 

Отчет об игре можно посмотреть в файле tests/test_files/perfect_game.out 

## Thread pool

Первое, что было предпринято - пул потоков. Пул потоков — шаблон параллельного программирования, который поддерживает несколько потоков, ожидающих выделения задач в очереди для выполнения. Основные преимущества:
- накладные расходы на создание и уничтожение потоков ограничены начальным созданием пула;
- пул потоков позволяет повторно использовать рабочие потоки после выполнения задач.

> boost::asio::thread_pool

Из библиотеки boost был использован класс boost::asio::thread_pool, приниающий в конструкторе число потоков в пуле. Каждая задача, которая помещается в очередь, должна представлять собой объект с перегруженным operator(). 

> T_Task

Был введен интерфейсный класс задачи T_Task с абстрактным методом operator(), каждый наследник переопределяет этот метод. Конструкторы наследников принимают 
- указатель на игровую комнату;
- структуру пользователяж;
- индекс ячейки на игровом поле.

Таким образом формируются объекты задачи, которые должны быть обработаны параллельно. 

> Стресс-генератор

Файлы tests/test_files/test_case_*.test содержат задачи, сгенерированные стресс-генератором. Каждая задача представляет собой строку, состояющую из
- id игровой комнаты
- тип действия, шаг или роллбэк (s или r)
- id игрока
- index ячейки, куда сходил игрок

В данном случае стресс-генератор использует тип действия "шаг" и id игрока, уникальный в рамках одной игровой комнаты (0 или 1). Тесты генерируются в файле tests/stress_test.cpp в первом тесте.

Изначально стресс-генератор генерировал случайные id комнаты, случайные id игроков и случайные индексы. Однако правила запрещают после хода первого участника второму участнику ходить в любую доступную ячейку, второй участник должен ходить в любую доступную ячейку определенного поля 3 на 3. Поэтому большое число сгенерированных задач не были выполнены и игровая комната возращала отчет с сообщением об ошибке: "текущих ход должен делать другой игрок", "ячейка уже занята", "правила игры запрещают ходить в данное поле 3 на 3" и другие. 

В связи с этим, генератор был переписан, и теперь он генерирует валидные ходы для каждого игрока. 81-го хода гарантировано достаточно, чтобы игра завершилась. 

> Стресс-тестирование

Проведено тестирование, которое оценивает надёжность, устойчивость системы и правильную работу логики игры в условиях превышения пределов нормального функционирования. В файле tests/test_thread_pool.cpp в функции ThreadPoolTest происходит чтение данных из файла, сгенерированного стресс-генератором, создание объекта задачи и сабмит задачи в очередь пула потоков: boost::asio::post(pool, task).

> Результаты

./build/tests/test_game --gtest_filter=TestThreadPool*

В результате выполнения было выяснено, что, несмотря на то, что в рамках одной комнаты в файле задачи распогалагаются правильно, и их последовательное выполнение должно приводить к завершению игры, потоки забирали задачи из очереди сразу после завершения предыдущей, не учитывая их последовательность. 

Таким образом, задачи в рамках одной игровой комнаты в хаотичном порядке завершали свое выполнение, большая их часть не проходила слой игровой логики (типы ошибок приведены выше) и игра не завершалась после выполнения всех задач.

Вывод отчетов по завершенным играм находится в файлах tests/test_files/n_thread_pool_rooms_*.out. 

Пул потоков был протестирован на объемах данных: 2 и 100 игровых комнат.

- 2   комнаты - игры завершены в 0 / 2
- 100 комнат  - игры завершены в 35 / 100

Было добавлено время ожидания основного потока между передачей команд в пул потоков. При увеличении времени задач выполнялось больше, но это уже не похоже на параллельность.
- 500 мкс - 100 / 100 задач 
- 300 мкс - 96  / 100 задач
- 100 мкс - 93  / 100 задач 
- 10  мкс - 91  / 100 задач 

> Вывод

При большом количестве одновременно поступающих запросов происходит рассинхрон в последовательности выполнения задач, однако если в браузере в рамках одной игровой комнаты запросы летят реже, чем раз в полсекунды, задачи не будут перемешиваться.

## 1 комната - 1 поток

> Сюжет 

- для каждой новой игровой комнаты создается отдельный поток
- во время выполнения задачи в одной комнате, потоки, обслуживающие другие комнаты, могут брать задачи и выполнять
- при завершении игры в комнате поток выходит из своей функции и присоединяется к основному

> Недостаток

Сколько одновременно активных комнат, столько и потоков, обслуживающих приложение. С учетом ограничения на количество ядер потоки будут скорее мешать друг другу, постоянно инициируя смену контекста. 

## Perf-тестирование

    TestConsistent_15   56 ms
    TestConsistent_100  364 ms
    TestConsistent_1000 5986 ms 

    TestStress_15       72 ms
    TestStress_100      394 ms
    TestStress_1000     6053 ms

    TestThreadPool_100  230 ms  (выполнено 3 задачи) 
    TestThreadPool_1000 5639 ms (выполнено 870 задач)

## Вывод

В нашем случае подойдет бустовский пул потоков, т.к. 
- класс прост в использовании
- 2 игрока в браузере в одной игровой комнате не могут инициировать 100 запросов в секунду

Однако, я считаю, что пул потоков стоит переписать под себя, организовав отдельную очередь для каждой комнаты. В каждой очереди задачи будут выполняться последовательно. Если в текущий момент в комната занята, хотя имеет невыполненные задачи в очереди, потоки буду искать другие задачи, которые связаны со свободными комнатами. 

